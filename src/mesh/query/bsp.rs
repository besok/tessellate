use crate::mesh::material::Color;
use crate::mesh::parts::polygon::Polygon;
use crate::mesh::query::bsp::build::try_build_bsp_tree;
use crate::mesh::query::MeshQuery;
use crate::mesh::{Mesh, MeshError, MeshResult};
use std::collections::HashSet;
use crate::mesh::parts::plane::Plane;

pub mod build;
pub mod query;

/// A Binary Space Partitioning (BSP) tree
/// The BSP tree is used to organize polygons in a 3D space
/// to facilitate operations like rendering and spatial queries.
pub struct BSPTree {
    root: Box<BSPNode>,
}

impl Into<Mesh> for BSPTree {
    fn into(self) -> Mesh {
        self.mesh(Color::default())
    }
}

impl<'a> TryFrom<MeshQuery<'a>> for BSPTree {
    type Error = MeshError;
    fn try_from(q: MeshQuery) -> MeshResult<Self> {
        q.try_bsp_tree(None)
    }
}

impl BSPTree {
    pub fn try_from_mesh(mesh: &Mesh, depth: Option<usize>) -> MeshResult<Self> {
        try_build_bsp_tree(&mesh.try_polygons()?, depth)
    }

    pub fn root(&self) -> &BSPNode {
        &self.root
    }

    /// Iterates over the tree in preorder
    /// Preorder: root, left, right
    pub fn iter_preorder(&self) -> query::BspPreorderIterator {
        query::BspPreorderIterator::new(&self.root)
    }

    /// Iterates over the tree in inorder
    /// Inorder: left, root, right
    pub fn iter_inorder(&self) -> query::InOrderIterator {
        query::InOrderIterator::new(&self.root)
    }

    /// Iterates over the tree in postorder
    /// Postorder: left, right, root
    pub fn iter_postorder(&self) -> query::PostOrderIterator {
        query::PostOrderIterator::new(&self.root)
    }

    /// Generates a mesh from the BSP tree
    /// The mesh is generated by collecting all the polygons in the tree
    /// and creating a mesh from them
    pub fn mesh(&self, color: Color) -> Mesh {
        let polygons: HashSet<Polygon> = self
            .iter_preorder()
            .flat_map(|node| node.polygons().clone())
            .collect();
        Mesh::from_polygons(polygons.into_iter().collect(), color)
    }

    /// Generates a mesh from the BSP tree planes
    pub fn plane_meshes(&self, size: f32, color: Color) -> Vec<Mesh> {
        let mut meshes = vec![];
        for node in self.iter_preorder() {
            if let BSPNode::Node { plane, .. } = node {
                meshes.push(plane.to_mesh(size, color.clone()));
            }
        }
        meshes
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum BSPNode {
    Leaf {
        polygons: Vec<Polygon>,
    },
    Node {
        front: Box<BSPNode>,
        back: Box<BSPNode>,
        polygons: Vec<Polygon>,
        plane: Plane,
    },
}

impl BSPNode {
    pub fn polygons(&self) -> &Vec<Polygon> {
        match self {
            BSPNode::Leaf { polygons } => polygons,
            BSPNode::Node { polygons, .. } => polygons,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::mesh::material::Color;
    use crate::mesh::query::bsp::{BSPNode, BSPTree};
    use crate::mesh::shape::cone::Cone;
    use crate::mesh::HasMesh;
    use crate::mesh::query::MeshQuery;
    use crate::turn_on_test_logs;

    #[test]
    fn smoke_test() {
        turn_on_test_logs();
        let fig = Cone::default();
        let mesh = fig.mesh();
        let query:MeshQuery = mesh.into();
        let bsp: BSPTree = query.try_into().unwrap();

        fn print_tree(node: &BSPNode, depth: usize) {
            match node {
                BSPNode::Leaf { polygons } => {
                    println!("{}Leaf: {:?}", " ".repeat(depth), polygons);
                }
                BSPNode::Node {
                    front,
                    back,
                    polygons,
                    plane,
                } => {
                    println!("{}Node: {:?}", " ".repeat(depth), polygons);
                    print_tree(front, depth + 1);
                    print_tree(back, depth + 1);
                }
            }
        }
        print_tree(&bsp.root, 0);

        // for node in bsp.iter_preorder() {
        //     println!("{:?}", node);
        // }
        //
        for node in bsp.iter_inorder() {
            println!("{:?}", node);
        }
    }

    #[test]
    fn viz_test() {
        turn_on_test_logs();
        let fig = Cone::default();
        let mesh = fig.mesh();
        let query:MeshQuery = mesh.into();
        let bsp: BSPTree = query.try_into().unwrap();

        let bsp_mesh = &bsp.mesh(Default::default());
        let planes = &bsp.plane_meshes(10.0, Color::default());
    }
}
